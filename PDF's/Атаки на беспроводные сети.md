**Деавторизация** — это изъятие прав клиента на выполнение некоторых действий, а **деаутентификация** — это процесс удаления записи о проведённом ранее сравнении введённого пользователем пароля с паролем, хранящимся в базе данных.

**Wi-Fi** — технология беспроводной передачи данных. Она базируется на основе стандартов [IEEE 802.111](https://ru.wikipedia.org/wiki/IEEE_802.11). _Wi-Fi_ имеет 2 диапазона — 5 ГГц /5 см (5160-5825 МГц) и 2.4 ГГц /12 см (2412 МГц-2472 МГц). Сигнал _Wi-Fi_ можно передать на расстояние около километра даже при низкой мощности передачи, но для приёма сигнала с _Wi-Fi_ маршрутизатора на большом расстоянии нужна антенна с усилением.

Зачем атакуем? Основной причиной является доступ к корпоративной сети через беспроводную сеть.
## **Перехват рукопожатия (handshake)**
**Рукопожатие** — (_handshake_ — хэндшейк) **в _Wi-Fi_ сети** — это обмен информацией между точкой доступа и пользователем в момент подключения. Эта информация содержит разнообразные ключи, обмен происходит в несколько этапов. Рукопожатие аутентификации устанавливает контекст между клиентом и сервером, который включает в себя ключи, необходимые для шифрования сообщений между сторонами.
- рукопожатие можно перехватить во время подключения клиента, который знает валидный пароль, к беспроводной точке доступа;
- рукопожатие содержит достаточно информации для расшифровки пароля.

Перехват рукопожатия применяется на стандарты _WPA/WPA2_, так как они используется в большинстве маршрутизаторов. _WPA/WPA2_ применяют протокол _EAPOL_ во время подключения к ТД. На этом этапе осуществляется поэтапная передача ключей шифрования между ТД и станцией, которая собирается подключиться. Необходимо перехватить передаваемые пакеты данных и определить правильный пароль методом грубой силы. Иначе говоря, вам нужно зафиксировать рукопожатие (на этапе применения _EAPOL_), а затем использовать брутфорс, чтобы определить правильный пароль.

## **Как перехватить хэндшейк**
Алгоритм достаточно простой:

- сканируем сеть на наличие доступных точек доступа,
- выбираем точку доступа, запоминаем её _ВSSID_ и номер канала,
- ожидаем рукопожатие, прослушивая выбранную точку доступа,
- (опционально) форсируем процесс путём применения [атаки деаутентификации](http://hackware.ru/?p=74).

Первым делом переведём сетевой интерфейс в режим монитора:
```
ifconfig wlan0 down && iwconfig wlan0 mode monitor && ifconfig wlan0 up
```
Смотрим доступные для атаки точки доступа:
```
airodump-ng wlan0
```
![[Pasted image 20250321035253.png]]
Я выбрал сеть _MiPhone_, её _ВSSID B2:9D:EF:51:92:5B_ на канале 1. Поэтому я запускаю [airodump-ng](http://kali.tools/?p=411) на первом канале:
```
airodump-ng wlan0 --channel 1 -w cap2
```
После ключа `-w` идёт префикс файла `cap2` (это имя без расширения). В этот файл будет записано захваченное рукопожатие.
Можно ничего не делать — достаточно просто ждать, когда кто-то подключится или переподключится естественным образом. Если вы торопитесь, то можно форсировать процесс использованием атаки деаутентификации.  
Для этого мы открываем новое окно терминала и набираем команду:

```
aireplay-ng -0 5 -a B2:9D:EF:51:92:5B wlan0
```
- аргумент `-0` означает деаутентификацию,
- `5` означает количество отправленных пакетов,
- `-a B2:9D:EF:51:92:5B` — это _ВSSID_ целевой ТД,
- `wlan0` — сетевой интерфейс в режиме монитора.

Результат не заставил себя долго ждать:
![[Pasted image 20250321035350.png]]
Надпись «_WPA handshake: B2:9D:EF:51:92:5B_» говорит нам о том, что рукопожатие уже захвачено. Простейший вариант использования _Aircrack-ng_:
```
aircrack-ng -w путь_до_словаря -e ТД рукопожатие.cap
```
![[Pasted image 20250321035438.png]]

### Основные функции `hcxpcapngtool`:

1. **Извлечение хэшей**:
    - Утилита извлекает хэши из файлов захвата (например, handshake WPA), которые затем могут быть использованы для офлайн-атаки методом перебора (brute force) или с использованием словарей.

2. **Конвертация форматов**:

    - Преобразует файлы `.pcap` или `.pcapng` в другие форматы, которые могут быть
    - использованы инструментами для взлома, такими как `hashcat` или `john the ripper`.

3. **Фильтрация данных**:
- Позволяет фильтровать и обрабатывать только нужные данные из захваченного
- трафика, что упрощает дальнейший анализ.    

https://hashcat.net/cap2hashcat/
Либо через hcxpcapngtool
`hcxpcapngtool` — это утилита, используемая для обработки файлов захвата сетевого трафика (например, в формате `.pcap` или `.pcapng`), связанных с Wi-Fi, с целью извлечения информации, необходимой для взлома паролей WPA/WPA2. Она является частью набора инструментов `hcxtools`, которые применяются для анализа и атаки на Wi-Fi сети.

```
aircrack-ng 1_2_.pcap        
```

![[Pasted image 20250322013130.png]]



## **Evil Twin**
**Атака «злой двойник»** (англ. _evil twin_) — разновидность [фишинга](https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D1%88%D0%B8%D0%BD%D0%B3), применяемая в беспроводных сетях. Атакующий создаёт копию точки доступа, находящейся в радиусе приёма пользователя, тем самым подменяет оригинальную точку доступа двойником, к которому подключается пользователь, открывая злоумышленнику возможность доступа к конфиденциальной информации или получения пароля от точки доступа.

Атака основана на том, что каким-то устройствам достаточно лишь _ESSID_ (названия точки доступа) для того, чтобы сделать попытку аутентификации. Устанавливаем _wifiphisher_ c официального [GitHub](https://github.com/SkillfactoryCoding/HACKER-NetExploration-wifiphisher) проекта. Запускаем _wifiPhisher_ командой:
```
sudo wifiphisher
```
![[Pasted image 20250321054602.png]]
Злоумышленник видит все доступные вокруг точки доступа выбирает oдну.
![[Pasted image 20250321054618.png]]
В _wifiPhisher_ встроено несколько сценариев для реализации атаки _Evil Twin._
![[Pasted image 20250321054637.png]]
Жертва видит точку доступа, которая с виду не отличается от обычной и подключается к ней.
![[Pasted image 20250321054652.png]]

![[Pasted image 20250321054712.png]]
Пользователю приходит форма для аутентификации — чем правдоподобнее будет интерфейс, тем вероятнее получится положительный результат.

Клиент видит, что произошла какая-то ошибка, а в это время атакующий перехватывает данные и выключает работу поддельной точки доступа.
![[Pasted image 20250321054735.png]]
В зависимости от сценария получаем логин и пароль в открытом виде.  
Ещё одна схожая утилита, способная реализовать атаки типа _Evil Twin_, — _eaphammer_.

## **Режимы работы беспроводного адаптера**

Важнейшая характеристика, необходимая при проведении атак на беспроводные сети, — это то, способна ли наша сетевая карта работать в режиме монитора.Для того чтобы понять, для чего нужен режим монитора, обратимся к работе сетевого адаптера в режиме по умолчанию («управляемый», _managed_): каждое устройство получает пакет данных, _MAC_-адрес назначения которых совпадает с _MAC_-адресом устройства, получающего пакет.

**В режиме монитора** сетевая карта обрабатывает все беспроводные пакеты данных, передаваемые в радиоэфире на выбранной частоте. Она не соединена с какой-либо конкретной точкой доступа. В этом режиме сетевая карта обрабатывает любые пакеты данных на её частоте, доступные в заданном диапазоне.


Если наш сетевой адаптер находится в режиме монитора, он способен перехватить четырехэтапный хэндшейк. С помощью этого рукопожатия впоследствии можно получить пароль от Wi-Fi.

![[Pasted image 20250321013933.png]]

Этапы рукопожатия называются _Мessage 1_, _Мessage 2_, _Мessage 3_, Мessage 4.
_Мessage 1_ пакет приходит от точки доступа, в этом пакете содержится некоторый случайный набор байтов — _ANonce_. По этому случайному набору байтов вычисляется _ESID_, который отправляется в _Мessage 2_ пакете от клиента. _PTK_ — сеансовый ключ, _GTK_ — ключ для шифрования широковещательного трафика (_GTK_ используется для _ARP_-запросов, _NETBIOS_-запросов, с его помощью можно легко реализовать изоляцию клиентов). Имея _PTK_, клиент ТД смотрит _Мessage 2_, и если не обнаружено нарушений, отправляет пакет _Мessage 3_, содержащий созданные ключи. На что клиент подтверждает получение данных в _Мessage 4_ пакете либо говорит, что обнаружена ошибка.
==**Хэндшейк отправляется в _Мessage 2_, поэтому нам нужен только он.**==
Имея неподходящую сетевую карту, можно, например, воспользоваться утилитой routerscan. 
```
https://kali.tools/?p=501
```
С помощью данной утилиты можно определить имена доступных точек доступа, их шифрование и модель роутера.

Для ускорения данного процесса, используют **атаку деаутентификации** (мы вынуждаем клиента разорвать соединение, чтобы станция провела подключение к Точке Доступа повторно). Для её выполнения требуется, чтобы сетевая карты была способна посылать беспроводные инъекции (обозначается как режим _Inj_).

Для программ, создающих фейковую точку доступа с целью выполнить атаку типа «человек посередине», требуются _Wi-Fi_ карты, поддерживающие **режим Точки Доступа** (AP). В этом режиме работы сетевая карта выполняет функции беспроводного роутера: к ней могут подключаться другие станции.

Сетевая карта может поддерживать режим монитора, уметь делать беспроводные инъекции, но не иметь режим Точки Доступа. Чтобы определить что может _Wi-Fi_ карта, нужно уметь определять её чипсет и драйвер.

Для проведения атак на беспроводные сети наиболее важны следующие поля: _AP_, _Monitor_ и _Inj_.

С помощью команды `lsusb` мы можем узнать чипсет USB сетевой карты.
![[Pasted image 20250321015143.png]]
А командой `lsusb -t` можем вывести драйвер сетевой _USB_-карты:
![[Pasted image 20250321015157.png]]
Ту же информацию о чипсете и драйвере можем посмотреть с помощью утилиты `airmon-ng`.
![[Pasted image 20250321015216.png]]

Возможности сетевого оборудования можно узнать с помощью команды `iw list`. Эта команда отображает дополнительную информацию от сетевого интерфейса, не отображаемую _iwconfig_. Обратите внимание на список поддерживаемых сетевым интерфейсом режимов работы:
![[Pasted image 20250321015259.png]]

## **Проверка режима монитора, беспроводной инъекции и AP в Linux

Чтобы перехваченные данные были точны, следует закрыть программы, которые могут мешать нам работать с сетевой картой:
```
sudo systemctl stop NetworkManager
```

```
sudo airmon-ng check kill
```

## **Проверка режима монитора**

```
sudo iw dev
```
![[Pasted image 20250321015539.png]]

Она должна отобразить имя сетевого интерфейса в вашей системе. Если ничего не выведено, значит сетевая карта не подключена, либо система по какой-либо причине не может распознать вашу сетевую карту.  
В полученной информации найдите имя сетевого интерфейса, к примеру, это может быть _wlan0_. Далее выполните последовательность команд:

```
sudo ip link set <ИНТЕРФЕЙС> down
sudo iw <ИНТЕРФЕЙС> set monitor control
sudo ip link set <ИНТЕРФЕЙС> up
```
Заменив `<ИНТЕРФЕЙС>` на действительное имя вашего сетевого интерфейса (у меня это _wlan0_):
![[Pasted image 20250321015701.png]]
Затем вновь выполните команду:
```
sudo iw dev
```

![[Pasted image 20250321015720.png]]
Строка _type monitor_ говорит о том, что сетевая карта поддерживает режим монитора.

## **Проверка беспроводной инъекции**

Утилита `aireplay-ng` может определить, способна ли наша сетевая карта проводить инъекции на сетевом интерфейсе:
```
sudo aireplay-ng -9 wlan0
```
![[Pasted image 20250321015825.png]]
Главной в полученном выводе является строка _Injection is working!_, которая говорит о том, что инъекция работает.

## **Проверка режима ТД (AP, master)**
Режим работы сетевой карты в качестве точки доступа иначе называют **мастер режимом**. Данный режим нужен для атак, основанных на социальной инженерии. В ходе подобных атак, как правило, создаётся ложная точка доступа, идентичная натуральной.

Способна ли наша сетевая карта работать как точка доступа, мы можем определить, создав файл _hostapd.conf_ со следующим содержимым (_wlan0_ — имя проверяемого сетевого интерфейса):
![[Pasted image 20250321015929.png]]
Сохраним и закроем его, после чего запустим утилиту _hostapd_ следующим образом:
![[Pasted image 20250321015941.png]]
`hostapd` должен вывести следующую информацию:
![[Pasted image 20250321015955.png]]
Если `hostapd` выдал похожий ответ, то мы сможем с помощью второго устройства (телефона, планшета, электронных часов) найти в списке беспроводных сетей новую под именем _TestAP_.  
Если мы подключимся к этой точке доступа, у нас не будет доступа к интернету, так как она не маршрутизирует сетевой трафик. То, что вы видите эту новую сеть, означает, что ваша сетевая карта поддерживает мастер (_AP_) режим работы.

Командой
```
sudo iw dev
```
Можно убедиться, что режим работы установлен как _AP_ (строка _type AP_):
![[Pasted image 20250321020047.png]]

## **Проверка функциональности виртуального интерфейса**
Часть сетевых атак, например, обход _Captive Portal_, для реализации требуют проведения двух различных действий одновременно: глушение сигнала целевой ТД, после чего запуск двойника, фальшивой ТД.  
Для подготовки к данной атаке, нам следует выделить второй интерфейс из главного интерфейса (_wlan0_ — стандартный сетевой интерфейс). Для начала определим интерфейс и поставим его на прослушивание сетевого трафика. Для этого установим его в режим _monitor_:
![[Pasted image 20250321020623.png]]
Далее мы создаём виртуальный, второй интерфейс от основного интерфейса:
![[Pasted image 20250321020634.png]]
В нашем случае:

- _wlan0_ – название дефолтного сетевого интерфейса,
- _wlan0ap_ – имя второго интерфейса, можно выбрать любое другое.

Командой
```
sudo iw dev
```

мы можем убедиться, что 2-ой интерфейс был действительно добавлен:
![[Pasted image 20250321020716.png]]
Наши интерфейсы готовы. Попробуем теперь воспользоваться ими одновременно.

==При работе с интерфейсами, как правило, устанавливают следующие ограничения:==

- ==2 интерфейса должны работать на одной частоте (так как ложная ТД должна быть максимально похожа на настоящую ТД).==
- ==Интерфейс, настроенный на режим работы _master_ (_AP_) находится в связке с интерфейсом, имеющим режим _monitor_ (после поднятия ложной ТД, второй сетевой интерфейс будет переведён в режим работы _monitor_ автоматически)==

Протестируем теорию. Запустим атаку деаутентификации, а на 2-ом интерфейсе (_wlan0ap_), создадим ложную точку доступа.
Начнём с поиска цели. Переведём основной интерфейс _wlan0_ в режим монитора:
![[Pasted image 20250321020842.png]]
И запустим на нём [airodump-ng](https://kali.tools/?p=411):
![[Pasted image 20250321020853.png]]
Предположим, в качестве цели была выбрана сеть _Anastas_.
Она расположена на 10 канале и имеет _BSSID 2C:56:DC:40:EC:D4_ (3-я строка, запомним её):
![[Pasted image 20250321020914.png]]
А теперь создадим ложную точку доступа — двойник выбранной ТД. Для этого создадим файл _hostapd.conf_ со следующим содержимым:
![[Pasted image 20250321020940.png]]
Примечание: заметьте, что в конфиге изменилось название сетевого интерфейса на _wlan0ap_.

Запускаем _hostapd_, аргументом передаём в него только что созданный файл конфигурации:
```
sudo hostapd hostapd.conf
```

Командой `sudo iw dev` вы можете узнать текущий статус сетевых интерфейсов:
![[Pasted image 20250321021018.png]]
## **Атака деаутентификации**

Для деаутентификации (глушения) рекомендую использовать популярную утилиту [mdk4](https://kali.tools/?p=4246).

Использование:
```
sudo mdk4 <интерфейс> <режим_атаки> [опции_атаки]
sudo mdk4 <входной_интерфейс> <выходной_интерфейс> <режим_атаки>[опции_атаки
```

На основном интерфейсе запустите _mdk4_ следующим образом:
```
sudo mdk4 <интерфейс> d -c <канал_целевой_ТД> -t <BSSID_целевой_ТД>
```

В моем случае команда выглядит так:
```
sudo mdk4 wlan0 d -c 9 -t 50:46:5D:6E:8C:20
```
Таким образом, пока работает _mdk4_, клиенты не смогут подключиться к настоящей ТД, но при этом будет доступна наша ложная ТД, имеющая точно такое же название. Она не требует пароль при подключении. Притом обе операции будут выполняться при использовании единственного _Wi-Fi_ адаптера.
![[Pasted image 20250321021244.png]]
Всего у _mdk4_ имеется 9 модулей атаки, они обозначаются одной буквой (мы использовали модуль под буквой `d`):
![[Pasted image 20250321021257.png]]

==_mdk4_ и _hostapd_ должны работать исправно и одновременно. Их слаженная работа поможет нам успешно провести атаку типа «человек посередине». Далее эти атаки будут рассмотрены более подробно.==


## Открытые точки доступа, шифрование, перехват рукопожатия
==**Captive Portal**== — это ещё один метод для ограничения количества клиентов. Используя такой подход, можно удобно регулировать предоставление доступа в сеть Интернет (к примеру, выдавать учётные данные, действительные в течение определённого периода) и отслеживать активность определённого клиента.

Бывает, что для получения доступа в интернет хватает _PIN_-кода из _SMS_-сообщения или можно попросить имя пользователя и пароль на ресепшене. Но бывает и так, что нужно покупать доступ.

Если же _Captive Portal_ всё-таки используется, можем попытаться обойти его, воспользовавшись особенностями реализации. Чтобы увидеть, из-за чего настолько легко можно минуть _Captive Porta_l, и понять другие методы обхода, нужно уложить в голове, как по сути устроен _Captive Portal_.

_Captive portal_ применяются на открытой точке доступа, а значит, к ним способен подключиться любой желающий. Эту информацию следует выделить – у атакующего без какого-либо взлома есть доступ к локальной сети. Вы, конечно, правы, если вам пришло на ум слово «[сниффинг](https://hackware.ru/?tag=%D1%81%D0%BD%D0%B8%D1%84%D1%84%D0%B8%D0%BD%D0%B3)» после словосочетания «локальная сеть».

Сеть настроена так, что все подключившиеся клиенты будут перенаправлены на страницу, содержащую условия получения доступа в сеть. На такой странице от клиента требует ввести ПИН-код из СМС, либо имя пользователя/пароль. Как правило, для получения доступа к странице _Captive Portal_ используется протокол _HTTP_ (а не _HTTPS_). Обусловлено это некоторыми особенностями функционирования сети – для локальных адресов невозможно создать валидные _SSL_-сертификаты, но при использовании невалидных сеть не становится безопаснее, а возникают новые проблемы.

В том случае, когда при попытке подключиться к _Captive Portal_ и открытия страницы в браузере, переадресации на страницу Портала не происходит, то, скорее всего, суть в том, что вы заходите на сайт, использующий _HTTPS_-протокол. Попробуйте открыть сайт, использующий _HTTP_, и вас перебросит на страницу Перехватывающего Портала.

Чтобы клиенты не догадались воспользоваться не часто используемыми портами (к примеру, воспользоваться [браузером Tor](https://kali.tools/?p=2069) или _vpn_), трафик по всем портам блокируется. Исключение составляет _UDP_-трафик на 53 порту – это требуется для отправки запросов на _DNS_-сервер.
Как только клиент ввёл свои учётные данные, его _MAC_ и _IP_-адресу предоставляется неограниченный доступ в сеть. Привязка происходит конкретно к _MAC_-адресу (реже к связке _MAC_-адрес и _IP_-адрес), так как иначе проблематично организовать доступ.
Современные устройства требуют полного подключения к сети: почтовые клиенты, антивирусы, онлайн игры и т. д. Нельзя ограничится куки в браузере: требуется предоставить неограниченный доступ для клиента, какой бы порт ему ни был нужен.
Уникальный идентификатор сетевых устройств – _MAC_-адрес помогает запоминать устройство, имеющее доступ к сети. _Captive Portal_ способен создавать куки в браузере, но они носят второстепенный характер: как правило, они используются для ускорения аутентификации.

## **1 метод обхода _Captive Portal_: кража _MAC_ и _IP_-адреса _hack-captive-portals_**

https://kali.tools/?p=3858

```
sudo apt -y install sipcalc nmap
```

```
wget https://raw.githubusercontent.com/systematicat/hack-captive-portals/master/hack-captive.sh
```

```
sudo chmod u+x hack-captive.sh
```

```
sudo ./hack-captive.sh
```
![[Pasted image 20250321022636.png]]
У скрипта весьма несложный принцип работы – ищем всех «живых» хостов в сети и по порядку копируем _MAC_ и _IP_ хоста. После их изменения проводится проверка – доступен ли нам Интернет. В случае, если доступен, то скрипт прекращает работу, и мы получаем доступ к сети под чужим _MAC_-адресом. В случае, когда сеть недоступна, пробуем следующий в списке _MAC_ и _IP_-адрес подключенных пользователей.

Простой способ, но **очень** эффективный. Главное ограничение – в сети уже должен быть авторизованный в _Captive Portal_ клиент. По сути, можем выписывать рабочие пары _MAC_-адрес//_IP_ и использовать их, если клиент не совершает активных действий в сети. Правда такие комбинации могут быть действительными в заданном промежутке времени, к примеру, в течение суток с момента аутентификации.

## **2 метод обхода _Captive Portal_: использование _UDP VPN_ на 53 порту**

Как правило, клиентам, которые не прошли аутентификацию в _Captive Portal_, недоступен ни один _TCP/UDP_ порт. Каждый порт заблокирован, за исключением единственного – _UDP_/53 порта. При стандартном функционировании сети, данный порт используется для отправки запросов к _DNS_-серверам, с целью преобразования имён хостов в _IP_-адреса. Начать стоит с проверки наличия спуфинга _DNS_-запросов (в большинстве случаев нет). Чтобы осуществить проверку, запустите 2-3 раза системную команду [dig](https://zalinux.ru/?p=2783), при каждом запросе нужно указать новый хост. К примеру, чтобы получить IP хоста _ya.ru_:
![[Pasted image 20250321023044.png]]
Чтобы получить _IP_ хоста _google.com_:
![[Pasted image 20250321023056.png]]
В случае, когда результаты отличаются (возвращаются разные _IP_ на разный хост, а не внутренний _IP_-адрес), то _DNS_-запросы проходят – 53 _UDP_-порт открыт. Через _UDP_/53 порт возможно сконфигурировать _VPN_, _UDP_ прокси или другое туннелирование. 
_Free UDP-VPN_ для 53 порта можно найти в Интернете в свободном доступе.

==Iodine==
На сервере, который будет принимать туннелированные DNS-запросы, выполните следующую команду:

```
sudo iodined -f -c -P ваш_пароль 10.0.0.1 ваш.домен
```
- `-f` — запуск в foreground (для отладки).
- `-c` — отключение проверки IP-адресов клиента.
- `-P ваш_пароль` — пароль для подключения клиентов.
- `10.0.0.1` — IP-адрес, который будет назначен туннелю (можно выбрать любой приватный IP).
- `ваш.домен` — домен, который будет использоваться для DNS-запросов (например, `tunnel.example.com`).
Настройка клиента:
```
sudo iodine -f -P ваш_пароль ваш.домен
```
- `-f` — запуск в foreground.
- `-P ваш_пароль` — пароль, указанный на сервере.
- `ваш.домен` — домен, который вы использовали на сервере.

Настройка маршрутизации
Чтобы весь интернет-трафик шёл через туннель, настройте маршрутизацию:
```
sudo route add default gw 10.0.0.1
```
## **3 метод обхода Captive Portal: получение учётных данных легитимных пользователей**

Так как в _Captive Portal_ мы находимся с другими клиентами в одной локальной сети, а данные, используемые для авторизации на _Captive Portal_ передаются по протоколу _HTTP_, то мы можем использовать следующую рабочую схему:

- подключаемся к открытой сети,
- запускаем ARP-спуфинг,
- запускаем сниффинг,
- анализируем полученные данные: ищем в них логин и пароль.

На практике _Captive Portal_ может быть заполнен фейковыми клиентами, и эти иллюзии мешают нормальной работе таких программ как [Bettercap](https://kali.tools/?p=345), вследствие чего атака не всегда проходит успешно.

Мы также можем воспользоваться тем фактом, что в открытых сетях данные передаются без шифрования. Поэтому мы можем не подключаться к сети, а просто слушать трафик с помощью _Airodump-ng_ [[Источник](https://hackware.ru/?p=4943)].
## **Защита от обхода _Captive Portal_**
Борьба с обходом _Captive Portal_ в большинстве случаев сводится к защите от _Arp spoofing_'а. С этим может помочь «режим изоляции» на точке доступа — подробности стоит посмотреть на сайте производителя устройства.
Борьба с обходом _Captive Portal_ в большинстве случаев сводится к защите от _Arp spoofing_'а. С этим может помочь «режим изоляции» на точке доступа — подробности стоит посмотреть на сайте производителя устройства.



## **Точки доступа WEP**
**WEP** расшифровывается как _Wired Equivalent Privacy_ (безопасность, равная проводной). К сожалению, название не соответствует действительности. В беспроводных сетям данный режим безопасности считается устаревшим и предоставляет низкий уровень защиты. В ОС _Windows WEP_ обозначается как _Open_ — открытый тип подключения.
https://lib.itsec.ru/articles2/Inf_security/mify-i-pravda-o-wifi
![[Pasted image 20250321033619.png]]
_Chopchop_ позволяет быстрым подбором расшифровывать отдельные пакеты вообще без восстановления _WEP_-ключа. Именно эта программа и послужила своего рода плацдармом для расширения атаки на _WPA_.
Алгоритм _chopchop_ анализирует пакет данных, отрезает по 1 байту в конце пакета и изменяет кэш-сумму так, чтобы этот последний байт стал отсортированной последовательностью от 0 до 256 (поскольку известно, что контрольная сумма не шифруется). Далее _chopchop_ отправляет каждый из модифицированных пакетов маршрутизатору. Он отклоняет пакеты данных, у которых кэш-сумма не проходит циклическую проверку избыточности.
Так, среди 256 попыток отправки один байт расшифрованного пакета данных гарантированно совпадает. После успешного подбора этого байта, _chopchop_ переходит на следующий.

Простой способ провести эту атаку — воспользоваться утилитой _hostapd_.
![[Pasted image 20250321033749.png]]
После этого поднимаем точку доступа и подключаем к ней любое устройство.
![[Pasted image 20250321033808.png]]
Включаем режим монитора на сетевом адаптере. Запускаем
```
sudo airodump-ng wlan0
```
Видим, что у есть сеть, использующая _WEP_ в качестве защиты.
![[Pasted image 20250321033844.png]]
Запускаем атаку на данную точку доступа.
```
sudo airodump-ng wlan0 --bssid <MAC> -c 6 -w WEPcrack
```
Для реализации атаки на метод шифрования _TKIP_ накапливаем большое количество пакетов — точно около 80000, возможно, получится и с меньшим количеством.

![[Pasted image 20250321033930.png]]

Как только накопилось нужное количество пакетов, прекращаем прослушивание командой `Ctrl+C`.
![[Pasted image 20250321033940.png]]
Отправляем дамп в _aircrack-ng_:
```
sudo aircrack-ng <.cap file>
```

Получаем результат – ключ к Точке Доступа подобран.
![[Pasted image 20250321034009.png]]
Принципиально важно то, что протокол _WEP_ не запрещает бесконечное тестирование вариантов в таком режиме — здесь нет никаких мер защиты от подобных злоупотреблений.
## **Точки доступа WPA**
**Wi-Fi Protected Access** (защищённый _Wi-Fi_-доступ). Существует 2 вида:
- _WPA-Personal_ (_Personal Key/PSK_),
- _WPA-Enterprise_.
![[Pasted image 20250321034138.png]]

1. [AP](https://en.wikipedia.org/wiki/Wireless_access_point) передаёт временное значение _nonce-value_ (_ANonce_) в _STA_ и вместе с этим значением счётчик воспроизведения ключей. Этот счётчик считает количество переданных сообщений и отбрасывает повторные сообщения.
2. _STA_ в ответ передаёт собственное значение (_SNonce_) на точку доступа вместе с [кодом целостности сообщения](https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%B8%D1%82%D0%BE%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0) (_MIC_). Этот код может включать в себя также код аутентификации (_MAIC_). Кроме того, в этом сообщении передаётся обратно счётчик из первого кадра.
3. _AP_ проверяет _М2_, а именно соответствие _ANonce_, _RSN_, _MIC_ и значение счётчика воспроизведения ключей. В случае, если всё верно, ТД создает и отправляет _GTK_ с другим кодом целостности сообщения.
4. _STA_ проверяет _М3_, в частности _MIC_ и значение счётчика. Если поле счётчика действительно, отправляет подтверждение _AP_.

WPA обычно использует алгоритм шифрования [TKIP](https://ru.wikipedia.org/wiki/TKIP).

**WPA2** — новая, улучшенная версия протокола _WPA_. Может так же функционировать в режимах _PSK_ и _Enterprise_. Отличается от _WPA_ тем, что поддерживает тип шифрования _AES CCMP_.
## **Атака на основе WPS**
**WPS** расшифровывается как _Wi-Fi Protected Setup_ (защищённая установка) является протоколом (и одноимённым стандартом), используемым с целью упростить создание и конфигурирование сети _Wi-Fi_ [[Источник](https://zen.yandex.ru/media/id/5e79af0605140c7f02909152/ataka-na-wifi-s-wps-ispolzuia-reaver-5f397d4823035e4cde15c837)].

_WPS_ был разработан, чтобы облегчить настройку безопасной точки доступа для среднего домовладельца. Впервые он был представлен в 2006 году, а к 2011 году было обнаружено, что у него есть серьезный недостаток конструкции. ПИН-код _WPS_ может быть достаточно просто взломан.

Всего существует 2 вида WPS:

1. _WPS_ с _PIN_-кодом, состоящим из 8 чисел — на станции и на ТД требуется ввести одинаковый _PIN_-код,
2. и второй вид — кнопка _WPS_, в этом случае требуется зажать кнопку на маршрутизаторе и на клиенте с задержкой не более двух минут, в этом случае они смогут установить соединение.

Маршрутизаторы, у которых включен _WPS_, уязвимы к прямому перебору ПИН-кода. Когда подобран _WPS_ ПИН-код, атакующий способен подключиться к ТД, а также определить её _WPA/WPA2_ пароль. Перебор возможно осуществить только для ТД, на которых требуется ввести цифры; невозможно его провести там, где необходимо нажать одновременно кнопки. 
Пин-код состоит из 8 чисел, поэтому, существует (100 000 000) комбинаций этих 8 цифр. Перебрав все эти комбинации, мы можем определить _PIN_-код ТД. Однако набор ПИН-кодов для перебора мы можем ощутимо сократить. Суть в том, что последнее число _PIN_-кода — это контрольная сумма, основанная на первых 7 цифрах. Получается, количество возможных комбинаций мы можем сократить до (10 000 000).
Авторизация с использованием _WPS_ подразумевает передачу клиентом следующей последовательности данных — _PIN_-код, пакеты _M4_ или _M6_ и ответы на эти пакеты от базовой станции.  
В случае, когда первые 4 цифры Пин-кода не совпали, ТД отправляет _EAP-NACK_ пакет сразу после получения сообщения _M4_, а если ошибка была в последних 3 числах (8-ое число мы не учитываем, т.к. оно генерится атакующим по формуле контрольной суммы), то после получения _M6_.
Итак, данная уязвимость протокола позволяет разделение пин-кода на 2 части — 4 начальных числа и 3 числа после, затем проверить каждую часть на соответствие с помощью базовой станции, которая указывает, правильная ли последовательность цифр была передана. Когда мы разбиваем _PIN_-код на 2 части, получаем (10 000) комбинаций для первой половины (4 цифры) и (1000) для второй части (3 цифры). В сумме мы получаем всего 11 000 комбинаций для решения задачи полным перебором. Это в 9000 раз меньше начального числа комбинаций ().
Подытожим. Вместо горы комбинаций (), мы имеем всего 2 ( и ). Достаточно проверить всего 11 000 комбинаций вместо 10 000 000.  
Кроме того, в некоторых маршрутизаторах в ходе исследования были обнаружены критические уязвимости в работе генератора случайных чисел. Данная уязвимость получила название _**pixie dust**_.
## **WPA2 Enterprise**
В связи с тем, что в данном методе аутентификации подлинность пользователя проверяется по открытому каналу, а также не все устройства требуют подлинного сертификата, открывается возможность атаки _Evil Twin_.

Особенности атаки _Evil Twin_ на режим _Enterprise_:

- разрешить всем пользователям аутентифицироваться с помощью _AP_ независимо от того, находится ли их имя пользователя в хранилище учётных данных _AP_,
- регистрировать/записывать все учётные данные и хеши, отправленные пользователем в AP.

Проводя эту атаку, злоумышленник практически ничего не должен делать, вредоносная точка доступа выдаёт слабые методы передачи данных и станции автоматически их принимают и подключаются.

Реализация будет проведена с помощью утилиты _eaphammer_, также возможно реализовать атаку вручную — т.е. самостоятельно поднять ТД и _RADIUS_ сервер.  
Команда для запуска утилиты:
```
sudo python3 eaphammer -bssid <mac-адресс> -essid <название сети> --channel <канал> --wpa-version 2 –auth wpa-eap –interface wlan0 --creds
```
Далее просто ждём и получаем логин и пароль в открытом виде.
![[Pasted image 20250321054955.png]]
Успешность атаки зависит от мощности _Wi-Fi_-адаптера и близости злоумышленника к мошеннической ТД.
## **Защита от атак на WPS**
Защититься от атаки можно одним способом — отключить _WPS_ с пином в настройках роутера. Правда это не всегда возможно, поскольку на некоторых устройствах _WPS_ отключается только полностью. Самое большее, что могут сделать производители — выпустить прошивку, позволяющую вводить таймаут на блокировку _MAC_-адреса, например, после 5 неудачных попыток ввода _PIN_-кода. Это увеличит время брутфорса.

В настоящее время остаётся все меньше устройств, у которых _WPS_ включен по умолчанию, в связи с чем актуальность атаки снижается, но проверять устройства на данную уязвимость все-таки стоит.
